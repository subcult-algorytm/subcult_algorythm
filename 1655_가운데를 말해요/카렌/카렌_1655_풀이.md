[1655번: 가운데를 말해요](https://www.acmicpc.net/problem/1655)
## 문제

백준이는 동생에게 "가운데를 말해요" 게임을 가르쳐주고 있다. 백준이가 정수를 하나씩 외칠때마다 동생은 지금까지 백준이가 말한 수 중에서 중간값을 말해야 한다. 만약, 그동안 백준이가 외친 수의 개수가 짝수개라면 중간에 있는 두 수 중에서 작은 수를 말해야 한다.

예를 들어 백준이가 동생에게 1, 5, 2, 10, -99, 7, 5를 순서대로 외쳤다고 하면, 동생은 1, 1, 2, 2, 2, 2, 5를 차례대로 말해야 한다. 백준이가 외치는 수가 주어졌을 때, 동생이 말해야 하는 수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에는 백준이가 외치는 정수의 개수 N이 주어진다. N은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수이다. 그 다음 N줄에 걸쳐서 백준이가 외치는 정수가 차례대로 주어진다. 정수는 -10,000보다 크거나 같고, 10,000보다 작거나 같다.

## 출력

한 줄에 하나씩 N줄에 걸쳐 백준이의 동생이 말해야 하는 수를 순서대로 출력한다.

## 시간 초과 코드

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
	std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    
    int N;
    std::cin >> N;
    
    std::vector<int> numbers;
	
	for(int i = 0; i <N; ++i)
	{
		int num;
		std::cin >> num;
		
		numbers.push_back(num);
		
		std::sort(numbers.begin(),numbers.end());
		
		// 벡터의 크기가 k일때 중간 인덱스는 (k-1)/2 이다.
		 
		std::cout << numbers[(numbers.size()-1)/2] << '\n';	
	} 
}
```

## 정답 코드 

```cpp
#include <iostream>
#include <vector>
#include <queue>

int main()
{
	std::ios_base::sync_with_stdio(false);
	std::cin.tie(NULL);
	
	int N;
	std::cin >> N;
	
	/*
	CPP는 기본적으로
	
	최대힙,내림차순으로 우선순위큐가 구현이 된다.
	
	만약, 최소힙을 구현 하고 싶을때는 명시적으로 형식을 나타내줘야한다.
	 
	*/
	
	// 최대힙 
	std::priority_queue<int> max_heap;
	
	//std::priority_queue<int,std::vector<int>,std::less<int>> max heap;
	
	std::priority_queue<int,std::vector<int>,std::greater<int>> min_heap;
	
	for(int i = 0; i <N; ++i)
	{
		int num;
		std::cin >> num;
		
		/*
		1. 두 힙의 size를 맞춰줘야한다.
		
		최대 힙의 size는 최소 힙의 size보다 같거나 1 커야한다.
		 
		*/
		
		if(max_heap.size()==min_heap.size())
		{
			max_heap.push(num);
		}
		else
		{
			min_heap.push(num);
		}
		
		/*
		
		2. 
		 
		최소 힙의 모든 값은 최대 힙의 모든 값 이상이여야 한다.
		
		만약 이 규칙을 지키지 못 할 경우 두 top의 값을 swap 해줌으로서
		
		이 규칙을 자연 스럽게 충족 시킨다.  
		*/ 
		
		if(!min_heap.empty() && (max_heap.top() > min_heap.top()))
		{
			int max_val = max_heap.top();
			int min_val = min_heap.top();
			
			max_heap.pop();
			min_heap.pop();
			
			max_heap.push(min_val);
			min_heap.push(max_val);
			
			// 중간 값은 최대 힙의 top 이다.
			
			
		} 
		
		std::cout << max_heap.top() << '\n';
		
	}
	
	return 0;  

}
```

---

## 문제를 풀 때 필요한 두가지 규칙

1.최대 힙의 size는 항상 최소 힙의 size 와 같거나 1 커야한다.

 : 이 규칙을 충족 시키기 위해 일단 최대 힙에 원소를 넣어주고, 만약 규칙이 깨질 경우에는 최소 힙의 top을 최대 힙으로 옮겨주는 작업을 한다.

2.최소 힙의 top보다 최대 힙의 top이 더 크면 안된다.

: 이 규칙을 충족 시키기 위해 만약 최소 힙의 top이 최대 힙의 top보다 커졌을 경우, 서로의 top을 교환해준다. 



---

## sort 함수

기본적으로는 오름차순으로 원소를 정렬해주는 함수이다.

```cpp
std::sort(시작_반복자, 끝_다음_반복자);
```

내림차순으로 할 경우에는
```cpp
std::sort(시작반복자,끝_다음_반복자,std::greater<int>());
```
로 하면 된다. 
## 최대 힙 

**부모 노드**가 항상 자식 노드 보다 값이 크거나 같은 힙이다.

이 문제에서는 중간 값보다 작거나 같은 값을 저장하는데 쓰였다.
## 최소 힙 

**부모 노드**가 항상 자식 노드 보다 값이 작거나 같은 힙이다.

이 문제에서는 중간 값보다 큰 값들을 저장하는데 쓰였다. 