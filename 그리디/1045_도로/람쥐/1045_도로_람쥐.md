
### 풀이 

문제를 통해 유추하기 어려워 보이는 문제이지만, 결론적으로 유니온 파인드를 통해서, 종착점을 찾고, 도로의 갯수를 세서, 각 종점의 도로의 수를 유추하는 문제 입니다. 

이 문제의 특이점은 튜플을 통해 우선순위를 선정한다는데에 있습니다. 

```
도로에는 우선순위가 있는데, A와 B가 (A < B) 도로 x로 연결되어 있고, C와 D가 (C < D) 도로 y로 연결되어 있을 때, 튜플 (A, B) < (C, D)이면 x > y, 즉 x의 우선순위가 더 높다.
```

이 말을 다시 한번 읽어보면, x > y 인경우만 카운트 하면되고, y > x 인경우는 카운트 하지 않아도 됩니다. 어자피 y > x 인 케이스는 x > y의 상태에 따라 override 되므로, 셀필요가 없다는 것입니다. 

이는 입력 부분에서 더 확실하게 설명 합니다.

``` 
즉 i번째 행의 j번째 열이 Y이면 도시 i와 j를 연결하는 도로가 존재하고, N이면 존재하지 않는다. i와 j가 연결되어 있으면 j와 i도 연결되어 있음이 보장되고, i와 i는 연결되어 있지 않다.
```

그러므로, x > y의 경우에만 카운트 해야 하므로, y > x  혹은 x = y 인 경우에는 아예 입력자체가 나오지 않게 막는것이 좋습니다. 


``` cpp 
for (int j = i + 1; j < a; ++j)
```

for loop에 명시적으로 j 값을 무조건 i 값보다 1 이상 높게 시작함으로써, j 인덱스와 i 인덱스가 같거나 작은 상황이 없게 만듭니다. 

그리고 

```
i 와 j 가 연결되어 있는경우 
- 하지만 parent가 같지 않으면 - partent 연결 

- 이미 연결되었다면 - continue 
  
```
의 로직을 통해, 공통 부모를 입력하고, 
0 서부터 해당 인덱스까지 부모에 연결된 RoadCount의 수를 세면 됩니다. 

```cpp 
#include <iostream>
#include <vector>
#include <utility>
#include <queue>
#include <cstring>


using namespace std;
constexpr int MAX_N = 50;
int parent[MAX_N];
queue<pair<int, int>> edge; // 세부적인 최적화 부분, vector 대신 queue를 사용해서 pop_back (요소 제거) 하는 시간을 줄일 수 있도록 한다. 
// 애초에 edge 자체는 부모에 연결되어있는 RoadCount의 숫자만 찾으면 되기때문. 

int find(int node)
{
	if (node == parent[node])
	{
		return node; 
	}
	return parent[node] = find(parent[node]); 
}

void united(int a, int b)
{
	parent[find(b)] = find(a); 
}

int main()
{
	// coordination of the road ->
	
	//    0 1 2
 	//  0 N Y Y   connected 1- 2 / 0-2 
	//	1 N N Y  connected 0-1 / 1 -2 
	//	2 Y Y N  connected 2 -0 / 1- 2
	// y > x index can be ignored. 

	int rC = 0; 


	int a, b; 
	cin >> a >> b; 
	vector<int>ans (a, 0); 
	vector<vector<int>> graph(a); 

	for (int i = 0; i < a; ++i)
	{
		parent[i] = i; 
	}
	for (int i = 0; i < a; ++i)
	{
		string line;
		cin >> line; 

		for (int j = i + 1; j < a; ++j)
		{
			if (line[j] == 'Y')
			{
				if (find(i) != find(j))
				{
					united(i, j); 
					rC++; 

					ans[i]++;
					ans[j]++; 
				}
				else
				{
					edge.push({ i,j }); 
				}
			}
		}
	}

	if (rC != a - 1) {
		cout << -1 << endl;
		return 0;
	}

	for (int i = a - 1; i < b; ++i)
	{
		if (edge.empty())
		{
			cout << -1 << endl; 
			return 0; 
		}

		ans[edge.front().first]++; 
		ans[edge.front().second]++; 
		edge.pop(); 
	}

	for (int i = 0; i < a; ++i)
	{
		cout << ans[i] << ' '; 
	}

	return 0; 

}
```