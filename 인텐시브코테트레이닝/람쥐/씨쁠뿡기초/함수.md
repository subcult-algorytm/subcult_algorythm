
- 함수를 사용하려면 어떤 과정이 필요한가요?
	 함수 정의, 함수 원형 작성, 함수 호출. 

- 배열을 리턴 하려면 어떻게 해야하나요?
	 구조체나 객체의 일부로 참조해야 합니다. 

- 만약 리턴값의 데이터형이 함수가 리턴해야하는 데이터형과 일치하지 않다면 어떻게 되나요?
	 리턴값의 데이터형이 변환가능하다면 그 리턴값을 함수가 원하는 데이터형으로 자동 변환합니다. 
	 이 경우 데이터 형이 변환 됨으로써 발생하는 오류가 있을 수 있습니다. 
	 하지만, 리턴값의 데이터형이 함수가 원하는 데이터 형으로 변환 할수 없거나, 정수값을 포인터로 변환하는등 이치에 맞지 않는 변환이라면 불가능 합니다.
	 이러한 비교는 컴파일시 이루어 집니다. (정적 데이터 형 검사)

- 배열의 이름은?
	 첫번째 원소의 주소로 간주합니다.
```cpp
int Euhe [4]; 

Euhe == &Euhe[0];
```

- 함수는 자기 자신을 호출 할수 있나요?
	 네, C++에서는 자기자신을 호출 해서 재귀호출이 가능합니다.

```cpp
void DFS (int start, const vector<vector<int>>& graph)
{ 
	stack<int> st;
	vector<int> visited; 
	st.push(start);
	
	while(!st.empty())
	{
		st.pop();
		if ()
	}
}
```

- 함수 포인터 (C-문법)
	https://aahc.tistory.com/17

- 함수 포인터를 사용하는 이유? 
	 특정함수를 콜백하기 위해서 사용합니다. 

- 함수포인터를 선언하는 방법
```cpp 
return_type (*pointer_name)(parameter_types);   
```

- 함수 포인터 사용하기 
``` cpp 
double pam (int); // 함수 원형을 먼저 선언합니다.

double (*pf) (int); // int를 파라미터로 취하고 double을 리턴하는 함수를 지시합니다. 

```

- 함수 포인터를 사용 할때의 주의점? 
	 함수포인터는 함수의 주소를 지시합니다. 
	 함수 포인터는 +/- 같은 연산지시자를 사용 할 수 없습니다. 
	 함수 포인터는 정확한 시그내쳐를 사용해야 합니다. 즉, 함수포인터가 어떤 데이터형을 지시하는지 선언에서 정확하게 지정 해야합니다.

```cpp
double(*pf)(int); // pf는 double을 리턴하는 함수를 지시하는 포인터. -> 함수 포인터

double *pf(int); // pf()는 double 형을 지시하는 포인터를 리턴하는 함수. -> double 형 포인터 리턴하는 그냥 일반 함수. 
```

- C++ 에서 함수포인터의 차이점은? 
	 C++에서는 함수 포인터 자체를 지정하는 함수를 호출하는 것처럼 사용 가능합니다. 
```cpp 
double Euhe(int); // 함수의 원형
double(*pf)(int); // 콜백을 하기위한 함수 포인터, 함수의 원형의 타입과, 파라미터를 맞춰야 합니다.

pf = Euhe; // 콜백함수를 바인딩 하는 로직

double x = (*pf)(4); // 함수 포인터로 콜백하는 방법. 
double y = pf(4); // C++ 에서 가능 
```

- 구조체 안에 함수를 함수를 만들수 있나요?
	 원칙적으로 불가능 하지만, 구조체 안에 함수포인터를 만들어 구조체의 맴버로 넣어서 쓸 수 있는 대안이 있습니다. 

https://www.geeksforgeeks.org/c/function-pointer-in-c/


- `inline` 함수에 대해 말씀해주세요.
	 인라인 함수는 프로그램의 실행속도를 높이기 위해, 코드영역 바깥에서 바로 그 자리에서 함수를 호출하기 위한 함수코드로, 함수의 크기가 작고 빈번할 때에만 사용합니다. 

- 매크로와 `inline`의 차이점은? 
-

- 참조변수 