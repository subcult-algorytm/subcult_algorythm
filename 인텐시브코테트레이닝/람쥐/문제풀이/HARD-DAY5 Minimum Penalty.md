https://www.hackerrank.com/challenges/beautiful-path/problem?isFullScreen=true
### 개요 
비트 연산자의 OR의 특징을 알고, 모든 경우를 서치하는 경우 어떻게 효율화 할수있는지 동시에 볼수있는 다소 고난이도의 문제입니다. 로직 효율화 + 복잡한 구현이 들어가므로 코테에 특히 공채 코테라면, 유력한 문제입니다. 수시채용 코테의 경우 이것보다는 덜 매운맛으로 나올 거같습니다. 
난이도는 다소 어려운편으로 여태 풀은 문제들 중 가장 어렵게 느껴졌습니다. 단순 BFS/DFS로 풀수 없고 여러가지 연산 과 예외처리를 합쳐 사용 해야 하므로 그런것으로 보입니다. 
설령 단순 BFS로 풀었다 한들, 시간 복잡도 테스트에서 걸렸을 가능성이 높습니다.

### 풀이 

일단 XOR 부터 이해하고 넘어가야합니다. 비트의 OR 연산자는 보통 작은 수를 리턴하는 경우가 많지만, 예외가 존재 합니다. 

4 or 2 = 6 , 4 or  = 4. 

그리고 일반적인 DFS, BFS로 풀기도 어려운 것이, 추가적으로 나올 수가 최소임을 보장 하지도 않는데다, 루프를 허용한다는 제약조건까지 가지고있어 더 어렵습니다. 

게다가 루프가 허용된다는 점, OR 연산 특성상 중복값이 많다는 점 때문에 DFS, BFS 풀이가 어렵습니다. 
예를 들어서 
6or 2 = 6, 6or 4 =6, 6or 6 =6 이므로 앞에서 2,4,6이 있고, 그 다음이 6이라면 3가지 연산을 모두 할 필요 가 없습니다. 

앞의 조건을 다시 본다면 노드의 최대값이 정해진것을 알수 있습니다. 1024개의 배열로 제한하고, 중복 연산을 피하는것이 관건입니다. 

1. 각 노드의 입력을 저장합니다
2. 모든노드를 1024 크기의 배열로 확보합니다
3. BFS DFS를 이용 서치합니다.

https://superpowercoding.github.io/hackerrank/2019/06/01/Minimum-Penalty-Path/
