
### 개요 
그래프 이론을 이용한 유니온 파인드 - DFS/BFS 문제입니다. 뭔가 이 둘은 묶여 가는거 같죠.
기본적으로 무언가 집합이 이뤄진다면 유니온 파인드를 생각해 볼법 합니다. 다만 코드의 길이 자체는 DFS가 짧고 간결하지만, 지금과 같이 2그룹 이상으로 나뉠수 있는 문제에서는 직관성이 떨어져, 구현 난이도가 상대적으로 어렵습니다. 그리고 유니온 파인드가 이런 유형의 문제에서는 더 구현속도가 빠른편으로, 집합을 통한 풀이는 유니온 파인드라고 접근하면 될 거 같습니다.
저는 DFS로 상상하지 못하는 허졉이기 때문에 유니온 파인드를 씁니다. 

전형적인 그래프 탐색 문제이고, 유니온파인드와 DFS를 취향에 맞게 가볍게 풀면 되는 문제이므로 클라코테 중간 문제로 낙점될 가능성이 높습니다. 

### 풀이 

일단 조건은 그렇습니다. 
- 일단 도로를 넣을수 있는 도시의 목록이 2차원 벡터로 주어집니다. 
- 모든 도시들이 연결되지 않을수 있습니다.
- 모든 도시에 도서관을 넣지 않아도 도로만 넣으면 주변 도시는 접근이 가능합니다. 
- 도시연결시, 도로건설시 비용이 있습니다.

먼저 드는 생각은 
- 도로건설 비용보다 도서관을 각각짓는 비용이 싸다면 굳이 지을 필요가 없겠구나! 
가 떠올라야 합니다.

그리고 유니온 파인드로 연결이 가능한 도시들을 묶은 뒤, 그 기반으로 최소 거리 탐방을 실시 해서 서로 이어 주면 건설 할수 있는 도로의 숫자가 나옵니다.
물론, 도로를 이어준다면 그 도로에 속한 도시중 최소 1개는 도서관을 가져야 겠죠? 
즉, 
- 예외를 제외한 건설비용 = 최소 탐방 비용 * 도로 건설 비용 + 집합의 수 * 도서관 건설비용 
이 됩니다. 


먼저 유니온 파인드에 가장 기초가 되는 유니온-파인드를 함수를 구합시다. 이정도면 그냥 외워도 되는 수준입니다.

```cpp


int find (int a)

{

	if (a == parent[a])

{

return a;

}

	return parent[a] = find(parent[a]);

}



void Unionised(int a, int b)

{

	a = find(a);

	b = find(b);

	if (a == b) return;

	if (size[a] < size[b]) swap(a,b);

	parent[b] = a;

	size [a] += size [b];

}
```


그리고 유니온 파인드를 모든 노드에 걸쳐 실행합시다.
```cpp 

// Runs Union Find!

for (int i = 1; i <= n; i++){

size[i] = 1;

parent[i] = i;

}

for (auto c: cities)

{

Unionised(c[0], c[1]);

}
```


그리고 모든 노드를 순회하면서, 갈수 있는 길에대한 탐방을 시작하고, 길의 사이즈 
```cpp
unordered_map<int,bool> umap;

long long cost = 0;

for (int i = 1; i <= n; i++)

{

int p = find(i);

if (umap[p]) continue;

cost += c_lib;

cost += ((long long)(size[p] -1 )*c_road);

umap [p] = 1;

}

return cost;

```


#### 구현부 탐구 

## **이 코드가 하는 일:**

이 코드는 모든 연결된 컴포넌트를 찾아서 각 컴포넌트에 대한 최적 비용을 계산합니다.

## **단계별 설명:**

### **1. 변수 초기화**

```cpp
unordered_map<int,bool> umap;  // 이미 처리한 컴포넌트 루트를 추적
long long cost = 0;            // 총 비용 누적기
```

### **2. 모든 도시 순회**

```cpp
for (int i = 1; i <= n; i++)
```

1번부터 n번까지 모든 도시를 확인합니다.

### **3. 컴포넌트 루트 찾기**

```cpp
int p = find(i);  // 도시 i가 속한 컴포넌트의 루트/대표자를 찾음
```

- `find(i)`는 도시 `i`가 속한 컴포넌트의 루트를 반환
- 같은 컴포넌트에 속한 모든 도시들은 같은 루트를 가짐

### **4. 이미 처리된 컴포넌트 건너뛰기**

```cpp
if (umap[p]) continue;  // 이미 이 컴포넌트를 처리했다면 건너뛰기
```

- `umap[p]`로 이 컴포넌트의 비용을 이미 계산했는지 확인
- 각 컴포넌트는 한 번만 계산하고 싶음

### **5. 이 컴포넌트의 비용 계산**

```cpp
cost += c_lib;                                    // 컴포넌트당 도서관 1개 추가
cost += ((long long)(size[p] - 1) * c_road);    // 컴포넌트 내 도시들을 연결할 도로 추가
umap[p] = 1;                                     // 이 컴포넌트를 처리완료로 표시
```

## **핵심 아이디어:**

크기가 `k`인 각 연결 컴포넌트에 대해:

- **도서관 1개**가 필요 (전체 컴포넌트를 서비스 가능)
- **도로 (k-1)개**가 필요 (k개 도시를 모두 연결하기 위해)

## **예시로 이해하기:**

`n=5`이고, 컴포넌트가 `{1,2,3}`과 `{4,5}`라고 가정:

```
i=1: p=find(1)=1, size[1]=3, umap[1]=false
     cost += c_lib + (3-1)*c_road = c_lib + 2*c_road
     umap[1] = true

i=2: p=find(2)=1, umap[1]=true → 건너뛰기 (컴포넌트 {1,2,3} 이미 처리됨)

i=3: p=find(3)=1, umap[1]=true → 건너뛰기 (컴포넌트 {1,2,3} 이미 처리됨)

i=4: p=find(4)=4, size[4]=2, umap[4]=false  
     cost += c_lib + (2-1)*c_road = c_lib + 1*c_road
     umap[4] = true

i=5: p=find(5)=4, umap[4]=true → 건너뛰기 (컴포넌트 {4,5} 이미 처리됨)
```

**최종 비용:** `2*c_lib + 3*c_road`

- 도서관 2개 (컴포넌트당 1개)
- 도로 총 3개 (첫 번째 컴포넌트에 2개 + 두 번째 컴포넌트에 1개)

## **왜 이렇게 작동하는가:**

1. **각 컴포넌트는 정확히 도서관 1개가 필요** - 도로를 통해 컴포넌트 내 모든 도시에 접근 가능
2. **크기가 k인 각 컴포넌트는 정확히 (k-1)개의 도로가 필요** - 최소 신장 트리 원리
3. **`umap`은 각 컴포넌트를 정확히 한 번만 계산하도록 보장** - 모든 도시를 순회하지만 중복 계산 방지

이것이 그리디 알고리즘의 핵심입니다: 각 컴포넌트를 연결하는데 필요한 최소 도로를 건설하고, 컴포넌트당 도서관을 하나씩 배치하는 것입니다.


### 히든 케이스 오류가 나는 이유? 

  - 엣지 케이스 (예외처리)를 제대로 안했을경우.
  - 오버플로우가 생겨서 다른 값을 도출한 경우. 
  - 혹은 잘못된 컨테이너 접근 

셋 중의 하나의 가능성이 높습니다.

위 코드는 long 에서 long long 을 리턴하는 방식으로 전환 했더니 모든 테스트 케이스에서 통과 할수 있었습니다. 즉, 오버플로우 문제 였던 것입니다. 

#### DFS로 푸는 방법은? 

```cpp 
long long solve_simple(int n, int c_lib, int c_road, vector<vector<int>>& cities) {
    // 도서관이 더 싸면
    if(c_lib <= c_road) {
        return (long long)n * c_lib;
    }
    
    // DFS로 컴포넌트 찾기
    vector<vector<int>> graph(n+1);
    for(auto& road : cities) {
        graph[road[0]].push_back(road[1]);
        graph[road[1]].push_back(road[0]);
    }
    
    vector<bool> visited(n+1, false);
    long long total_cost = 0;
    
    for(int i = 1; i <= n; i++) {
        if(!visited[i]) {
            int size = dfs(i, graph, visited);
            total_cost += c_lib + (long long)(size - 1) * c_road;
        }
    }
    
    return total_cost;
}
```