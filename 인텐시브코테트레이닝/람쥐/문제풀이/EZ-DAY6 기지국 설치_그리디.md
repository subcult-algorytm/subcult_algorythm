https://school.programmers.co.kr/learn/courses/30/lessons/12979
### 개요 
그리디 문제는 점화식으로 문제를 풀며, 점화식을 실행하고 나서 그 다음의 시도가 영향을 받지 않고 계속 재귀적으로 사용할수 있을때 사용 가능합니다. 즉, 점화식을 끝까지 재활용 하면 최적해를 가질수있는 문제가 그리디 사용이 가능합니다.

기지국 설치 문제는, 기지국의 넓이와 위치를 가지고 점화식을 도출해 배열 내에서 포인터처럼 이동을 하는 문제입니다. 

투포인터가 아니라 원포인터 문제라고도 할수 있겠네요. 


### 풀이

점화식은 다음과 같습니다. 

기지국의 위치의 양 옆으로 M 만큼 신호가 잡힙니다. 그 말은. 
`location + m *2` 만큼 기지국의 영향 범위니,  이 범위에는 기지국이 들어올 필요가 없습니다.
기지국이 들어오기 좋은 자리는,
`location + m` 위치이고 이 곳에 기지국의 영향이 최소가 되어야합니다. 즉, location +m 자리 로부터. location -m 자리까지는 기지국의 영향에 없어야합니다. 그렇기 때문에
기지국의 영향력인 곳을 넘어가야한다면 
2 x w+1 을 해서 기지국을 넘어가고, 설치하면됩니다.

초기 로케이션 location, 즉 기지국이 닿지 않은 가장 왼쪽집의 번호 (1) 부터 시작하고, 
stations는 이미 설치된 기지국의 위치입니다.
w는 반경으로, 좌우로 커버하는 자리입니다. 

```cpp
int answer = 0; 
int location = 1; 
int indx = 0;
```

그리고 station 값이 소팅이 되어있지 않았을수도 있으므로, 

```cpp
sort(stations.begin(), stations.end());
```
로 오름차순 정렬을 먼저 해야합니다. 본 문제에서는 그럴 필요가 없었지만, 예외처리는 꼼꼼히 하는것이 좋습니다.

루프를 보면  location 이 n (최대치) 까지 가기 전까지 발동되며, 첫번째로 기지국의 커버리지 왼쪽을 먼저 탐색합니다. 

```cpp
if(indx < stations.size() && location >= stations[indx]- w) 
```

이 부분은 기지국 커버리지의 왼쪽 부분을 탐색하는 부분이며, 
만약 기지국의 커버리지 안에 들어갔는데, 그것이 왼쪽 끝부분이라면, 

``` cpp
location = stations[indx] + w +1; 
```

으로 포인터를 옮겨주고, 다음기지국으로 indx ++ 합니다. 

기지국의 커버리지까지 닿지 않은경우, 
```cpp
else 
	{ 
		location += 2* w+ 1; 
		answer++; 
	} 

```

로 포인터를 옮기고 기지국을 설치합니다. 

```cpp
while (location <= n) 
{ 
	if(indx < stations.size() && location >= stations[indx]- w) 
	{ 
		location = stations[indx] + w +1; 
		indx++;
	} 
	else 
	{ 
		location += 2* w+ 1; 
		answer++; 
	} 
		
} 
return answer;

```

답은 다음과 같습니다.


#### 유의할점 

그리디 알고리즘은 한 점화식으로 끝까지 사용 가능하고, 선택과정이 다른 과정에 영향을 주지 말아야합니다. 최소신장트리와 특정 거스름돈 문제가 바로 이 문제에 해당됩니다.