
### Union - Find 
유니온과 파인드는 같이 묶여서 사용 되니 쌍으로 외워야 합니다.
유니온 파인드를 만들기 전, 부모의 목록을 저장하는 컨테이너가 필요합니다. 상황에따라 어레이 혹은 맵을 골라 사용하세요.

사용하기 좋은 경우 : 두개 이상의 그룹이 묶여지는게 확정 적인 경우. 단순 그래프 순회보다 더 효율적. 

```cpp
/* 
* 1. 부모를 담는 컨테이너 만들기 
* 2. 파인드 함수에서
	* 부모가 인자와 같으면 리턴 
	* 그렇지 않다면 최종 부모를 찾을 때가지 파인드 찾기
* 3. 유니온 함수에서.
	* 두 인자를 가지고 파인드를 실행
	* 두 인자의 부모를 합쳐줍니다.
*/

void Find (int a)
{
	if (a == parents[a])
    {
        return a; 
    }

    return parents[a] = find(parents[a]); 

}

void Union (int a, int b)
{ 
    a = find (a);
    b = find (b); 

    parents [b] = a; 
	
}

// 부모 찾기 - 같은 연결 안에 있는지 확인합니다! 
bool findParent (int a, int b)
{ 
    a = find(a);
    b = find(b); 

    if (a == b) return true; 
    else return false; 
}


```

###  DFS 
 깊이 우선 탐색입니다. 깊이 우선 탐색은 최소거리를 보장하지 않습니다! 다만, 미로 탐색, 미로 제작에서는 BFS보다 우선되어 사용됩니다.

```cpp 

```

### BFS 
너비 우선 탐색입니다. 너비 우선 탐색은 최소 거리를 보장합니다. 다만 미로 탐색, 미로 제작에서는 편향성 문제가 존재합니다. 


### 그리디 
그래프는 아니지만, 가끔 순회 문제에서는 그리디가 더 편한 경우도 존재 합니다.

사용하기 좋은 경우 : 명확한 룰 과 예외처리가 존재한 경우 그리디를 생각해 볼수 있습니다. 