
[1644번: 소수의 연속합](https://www.acmicpc.net/problem/1644)

# 문제

하나 이상의 연속된 소수의 합으로 나타낼 수 있는 자연수들이 있다. 몇 가지 자연수의 예를 들어 보면 다음과 같다.

- 3 : 3 (한 가지)
- 41 : 2+3+5+7+11+13 = 11+13+17 = 41 (세 가지)
- 53 : 5+7+11+13+17 = 53 (두 가지)

하지만 연속된 소수의 합으로 나타낼 수 없는 자연수들도 있는데, 20이 그 예이다. 7+13을 계산하면 20이 되기는 하나 7과 13이 연속이 아니기에 적합한 표현이 아니다. 또한 한 소수는 반드시 한 번만 덧셈에 사용될 수 있기 때문에, 3+5+5+7과 같은 표현도 적합하지 않다.

자연수가 주어졌을 때, 이 자연수를 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 구하는 프로그램을 작성하시오.

# 입력

첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 4,000,000)

# 출력

첫째 줄에 자연수 N을 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 출력한다.

# 예제 입력 1

```
20
```
# 예제 출력 1

```
0
```

# 예제 입력 2

```
3
```

# 예제 출력 2

```
1
```
# 예제 입력 3

```
41
```

# 예제 출력 3

```
3
```

# 예제 입력 4

```
53
```
# 예제 출력 4

```
2
```

---

# 소수 판별 방법

```cpp
#include <iostream>
#include <vector>

// 숫자 하나가 소수인지 판별 하는 함수 선언

using namespace std;

bool isPrime(int num)
{
	// 1 이하는 소수 아님2
	
	if(num <= 1)
	{
		return false;
	}
	// 2부터 num의 **제곱근** 까지의 모든 수로 나누어서 각각 본다.
	for(int i = 2; i*i <= num; i++)
	{
		// 자신 외에 나누어 떨어지는 부분이 있다면 소수 아님. 
		if(num % i == 0)
		{
			return false;
		}
	}
	
	//루프를 통과 할 경우 소수 이므로 true 반환
	return true;
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	
	// 사용자에게 입력 받는 부분
	
    int N;
    cin >> N;
	
	vector<int> primes;
	
	for(int i = 2; i <=N; i++)
	{
		if(isPrime(i))
		{
			primes.push_back(i); // isPrime 함수가 true를 반환 할 경우 vector에 i 추가
		}
	}
	
	cout << "Found " << primes.size() << " primes up to " << N << "\n";
	
	return 0;
}
```


시간 복잡도는 O(NsqrtN) 이 걸린다. 

1. 바깥쪽 반복 O(N) 
2. 안쪽 반복 (sqrt(N))

2부터 i의 제곱근까지 반복한다.

-> O(Nsqrt(N))
# 에라토스테네스의 체 

```cpp
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

vector<int> sieveOfEratosthenes(int n)
{
	// n+1 크기의 bool 자료형의 벡터를 만들고 모두 true로 초기화를 해준다.
	vector<bool> isPrime(n+1,true);
	
	//0과 1은 무조건 소수가 아니므로 false로 초기화 시킨다.
	isPrime[0] = isPrime[1] = false;
	
	// 에라토스테네스의 체 수행
	for(int p = 2; p * p <=n; ++p)
	{
		if(isPrime[p])
		{
			for(int i = p * p ; i <= n; i +=p )
			{
				isPrime[i] = false;
			}
		}
	}


// isPrime 벡터 기반으로 소수 목록 만들어 주기
vector<int> primes;

for(int p = 2; p <=n; ++p)
{
	if(isPrime[p])
		{
				primes.push_back(p);
		}
	}
	return primes;
}

int main()
{
	std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int N;
    std::cin >> N;
	
	// 예외 처리 부분
	
	if (N == 1) {
        std::cout << 0 << "\n";
        return 0;
    }
	
	// 함수 호출로 N 까지의 소수 목록 구하기 
	vector<int> primes = sieveOfEratosthenes(N);
	
	// 투 포인터를 사용하여 연속된 소수의 합 찾아 주기 
	int count = 0;
	int sum = 0;
	int start = 0;
	int end = 0;
	int prime_count = primes.size();
	
	while(true)
	{
		if(sum >= N){
			sum -= primes[start++];
		}
		else if(end == prime_count)
		{
			break;
		}
		else
		{
			sum += primes[end++];	
		}
		
		if(sum == N)
		{
			count++; 
		}
	}
	
	std::cout << count << "\n";
	
	return 0; 
}
```

이 알고리즘을 사용 할 경우 시간 복잡도는 O(NlogN)이 걸린다.

이유는

(N/2) + (N/3) + (N/5) + (N/7) + ....

이렇게 N까지의 모든 소수 P에 대해 N/p를 더한다고 해보면

이 식을 공통적으로 있는 N을 묶는다고 했을때

N{(1/2) + (1/3) + (1/5) + (1/7) + ...}

로 묶을 수 있다. 

여기서 괄호 안에 있는 (1/2 + 1/3 + 1/5 + ... )

'소수들의 역수의 합은 ' 수학적으로 logN 이라는 값에 근사 한다는 것이 증명이 되었다.

(이름 : 메르텐스의 제2정리)

그러므로 O(NlogN) 이 된다. 




