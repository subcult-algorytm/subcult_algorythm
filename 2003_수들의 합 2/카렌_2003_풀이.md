
[2003번: 수들의 합 2](https://www.acmicpc.net/problem/2003)

---

# 문제

N개의 수로 된 수열 A[1], A[2], …, A[N] 이 있다. 이 수열의 i번째 수부터 j번째 수까지의 합 A[i] + A[i+1] + … + A[j-1] + A[j]가 M이 되는 경우의 수를 구하는 프로그램을 작성하시오.
# 입력

첫째 줄에 N(1 ≤ N ≤ 10,000), M(1 ≤ M ≤ 300,000,000)이 주어진다. 다음 줄에는 A[1], A[2], …, A[N]이 공백으로 분리되어 주어진다. 각각의 A[x]는 30,000을 넘지 않는 자연수이다.
# 출력

첫째 줄에 경우의 수를 출력한다.

---

# 완전 탐색 코드 

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;

    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i];

    int count = 0;
    // 모든 구간 [i, j] 확인
    for (int i = 0; i < n; i++) {
        int sum = 0;
        for (int j = i; j < n; j++) {
            sum += arr[j];
            if (sum == m) count++;
        }
    }

    cout << count << "\n";
    return 0;
}

```

이 문제에서는 시간초과가 나지 않는다. 

위 코드 (완전탐색)의 시간 복잡도는 O(N^2) 이다.

이 문제의 최대 입력값은 10,000 이므로 O(N^2^4) 즉 O(N^8) 인데, 아슬아슬 하게 시간초과가 나지 않는다.  

만약에 이 문제의 최대 입력값이 더 컸으면 시간초과가 났을 것이다.

---

# 슬라이딩 윈도우 코드 
```cpp
#include <iostream>
#include <vector>

using namespace std;

int main()
{
	// 입력에 필요한 변수 만들어 주기
	int N,M; 
	
	cin >> N >> M;
	
	// 벡터 만들어 주기 
	vector<int> arr(N);
	for(int i = 0; i < N; i++) cin >> arr[i];
	
	// 범위 설정하는데 필요한 변수 만들어 주기
	int left = 0, right = 0;
	int sum = 0;
	int count = 0;
	
	while(true)
	{
		if (sum >= M)
		{
			sum -= arr[left];
			left++;
		}
		else if (right == N) break;
		else
		{
			sum += arr[right];
			right++;
		}
		
		if(sum == M) count ++;
	}
	
	cout << count << "\n";
	return 0;
}
```

투 포인터를 이용해서 최적화를 해 주었다.

주의 해야 할 점은 **반드시 정렬 후**에 양쪽에서 접근을 해야 한다는 것이다.

시간 복잡도는 O(N log N) 이 나온다. 

## break문이 중간 위치에 있는 이유?

코드를 보면 

```
else if (right == N) break;
```

가 끝 도 아니고 중간에 있는 것을 볼 수 있다.

만약에 끝에 위치해 있으면, 반복문이 올바르게 종료 되기 전에 right가 범위 초과를 해 버려 오류가 날 수 있으므로 반복문 중간 위치에 있는 것이다. 

