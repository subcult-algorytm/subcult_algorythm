from collections import deque

def 유효한_위치인가(x, y, 체스판_크기):
    return 0 <= x < 체스판_크기 and 0 <= y < 체스판_크기

def 나이트_이동_계산(시작_x, 시작_y, 체스판_크기):
    # 나이트가 이동할 수 있는 8가지 방향
    x_이동 = [-2, -1, 1, 2, 2, 1, -1, -2]
    y_이동 = [1, 2, 2, 1, -1, -2, -2, -1]
    
    # 방문 여부를 체크하는 배열
    방문_여부 = [[False] * 체스판_크기 for _ in range(체스판_크기)]
    # 각 칸까지의 이동 횟수를 저장하는 배열
    이동_횟수 = [[0] * 체스판_크기 for _ in range(체스판_크기)]
    
    # 시작 위치 방문 처리
    방문_여부[시작_x][시작_y] = True
    이동_횟수[시작_x][시작_y] = 0
    
    # BFS를 위한 큐 초기화
    큐 = deque([(시작_x, 시작_y)])
    
    while 큐:
        현재_x, 현재_y = 큐.popleft()
        
        # 8가지 방향으로 이동 시도
        for i in range(8):
            다음_x = 현재_x + x_이동[i]
            다음_y = 현재_y + y_이동[i]
            
            # 유효한 위치이고 아직 방문하지 않은 경우
            if 유효한_위치인가(다음_x, 다음_y, 체스판_크기) and not 방문_여부[다음_x][다음_y]:
                방문_여부[다음_x][다음_y] = True
                이동_횟수[다음_x][다음_y] = 이동_횟수[현재_x][현재_y] + 1
                큐.append((다음_x, 다음_y))
    
    return 이동_횟수

def 메인():
    # 테스트 케이스 수 입력
    테스트_케이스_수 = int(input())
    
    for _ in range(테스트_케이스_수):
        # 체스판 크기 입력
        체스판_크기 = int(input())
        
        # 시작 위치 입력
        시작_x, 시작_y = map(int, input().split())
        
        # 목표 위치 입력
        목표_x, 목표_y = map(int, input().split())
        
        # 최단 경로 계산
        이동_횟수 = 나이트_이동_계산(시작_x, 시작_y, 체스판_크기)
        
        # 결과 출력
        print(이동_횟수[목표_x][목표_y])

if __name__ == "__main__":
    메인()