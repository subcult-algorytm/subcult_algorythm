## [11286번: 절댓값 힙](https://www.acmicpc.net/problem/11286)

## 문제

절댓값 힙은 다음과 같은 연산을 지원하는 자료구조이다.

1. 배열에 정수 x (x ≠ 0)를 넣는다.
2. 배열에서 절댓값이 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다. 절댓값이 가장 작은 값이 여러개일 때는, 가장 작은 수를 출력하고, 그 값을 배열에서 제거한다.

프로그램은 처음에 비어있는 배열에서 시작하게 된다.

## 입력

첫째 줄에 연산의 개수 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 0이 아니라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 절댓값이 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 정수는 -231보다 크고, 231보다 작다.

## 출력

입력에서 0이 주어진 회수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 절댓값이 가장 작은 값을 출력하라고 한 경우에는 0을 출력하면 된다.

## 정답코드

#include <iostream>
#include <queue>
#include <vector>
#include <cmath>

using namespace std;

//priority_queue에 쓰일 cmp 구현 

struct cmp
{
    bool operator()(int a,int b) // 연산자 오퍼레이터
    {
        if(abs(a) == abs(b))
            return a > b;
        return abs(a) > abs(b);
    }     
}; 

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int N;
    cin >> N;

    priority_queue<int,vector<int>,cmp> pq;

    for(int i = 0; i < N; i++)
    {
        int x;
        cin >> x;

        if(x == 0) // x에 0이 들어왔을 경우 
        {
            if(pq.empty()) // pq가 비었을 경우 
            {
                cout << 0 << endl;    
            }
            else // pq가 비어있지 않을 경우 
            {
                cout << pq.top() << endl;
                pq.pop();
            }
        }
        else // x에 0이 들어오지 않았을 경우  
        {
            pq.push(x);
        }    
    }

    return 0;
}

---

## 연산자 오버로딩

연산자 오버로딩은 기본적으로 +,- 와 같은 연산자들을 사용자가 만든 class 나 struct에서 사용할때 어떤 작업을 수행할지 직접 정의하는 기능이다.

struct cmp
{
    bool operator()(int a, int b)
    {
        // ... 비교 규칙 ...
    }
};

위 코드는 괄호 ()를 사용해서 호출을 하면 , 정수 a와 b를 받아서 bool 값을 반환하기위한 연산자 오버로드이다.

즉, int 두개가 아닌 _string 이나 float 같은 다른 형식에는 먹히지 않는다._

## CMP의 우선순위 큐에서의 역할

우선순위큐는 기본적으로 최대힙으로 작동한다.

만약

priority_queue<int,vector<int>> pq;

인 경우에는

기본적으로 가장 높은 값이 가장 높은 우선순위로 오게 된다.

=> 절대 값이 가장 작은 수가 가장 높은 우선순위를 가지게 된다.

하지만 문제에서 요구하는 것은 **절대값이 작은 수가 높은 우선순위**를 가져야 하는 것이다.

그러므로, 별도로 세 번째 인자 cmp를 줘야한다.

이 부분이

priority_queue<int,vector<int>,cmp> pq;

이다.

struct cmp
{
    bool operator()(int a,int b) // 연산자 오퍼레이터
    {
        if(abs(a) == abs(b))
            return a > b;
        return abs(a) > abs(b);
    }     
}; 

  

bool 값을 변환할땐 해당 조건이 참일땐 true이고 거짓일땐 false를 반환한다는 것에 유의하고 코드를 본다. 

  

1. 만약 절대값이 같으면

  

a>b 가 참인지 거짓인지 본다. 참이면 true 거짓이면 false 이다.

  

2. 만약 절대값이 같지 않으면

  

abs(a) > abs(b) 가 참인지 거짓인지 본다.

  

여기서 문제에서의 우선순위큐는 cmp가 반환한 true,flase 값을 보고

  

1. true 이면

  

**a는 b보다 우선순위가 낮다**는 뜻으로 받아들인다.

  

2.false 이면 

  

**a는 b보다 우선순위가 높다**는 뜻으로 받아들인다. 

  

=> 순서를 바꾼다. 

main함수의 흐름

  

## main 함수 흐름 

  

1.첫번째 조건문 - x가 0인가 아닌가

  

-> 0이다. 

  

두번째 조건문으로 간다.

  

-> 0이 아니다.

  

pq.push(x)를 해줘서 큐에 원소 하나를 추가해준다. 

  

2.두번째 조건문 (첫번째 조건문에서 x가 0인것을 충족할 경우) - pq.empty() 의 반환값이 1인가 0인가

  

 -> pq.empty()가 false이다. 

  

cout를 사용해서 pq 맨 위에 있는 값을 출력해주고 (pq.top()) 이용

pq.pop() 을 사용해 맨 위에 있는 값을 큐에서 빼준다.

  

-> pq.empty()가 true이다.

  

0을 출력해준다.