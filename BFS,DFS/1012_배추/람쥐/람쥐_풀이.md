링크 - https://www.acmicpc.net/problem/1012

[[UsecaseCode.cpp]]
## 문제 요약 

유기농 배추를 심은 경로에 기반해서, 얼마나 많은 벌레가 필요한지에 계산. 
## 문제 분석 

유기농 배추를 심은 경로의 경로의 숫자가 몇개 인지 파악 해야 한다. **2D 배열에 연결이 되어있는 클러스터를 파악하고 그 갯수를 도출하는 문제.** 클러스터의 숫자를 센다면 벌레의 숫자를 셀 수 있다. 

## 의사 코드 

// 1. find the cabbage through the map  
// 2. if find the cabbage, start the travel to nearby cabbage.  
// 3. if there is no cabbage to travel, start to find the cabbage again  
// 4. Repeat the step 2 and 3 until all cabbage is founded. 


### 풀이 

[[1012.cpp]]

Visited 배열이 없는 풀이. 
[[1012_2.cpp]]
### 왜 Visited 배열이 필요한가요?? (by Claude)

대부분의 책과 강사들이 그래프 알고리즘에서 별도의 `visited` 배열을 사용하도록 권장하는 데는 좋은 이유가 있습니다:

1. **관심사의 분리**: 별도의 `visited` 배열을 사용하면 원본 데이터(`map`)를 그대로 유지할 수 있습니다. 이는 데이터 표현과 알고리즘 실행을 분리하는 좋은 프로그래밍 관행입니다.
    
2. **코드 명확성과 유지보수성**: 특정 목적을 위한 전용 배열을 사용하면 코드를 이해하기 쉬워집니다. 누군가 당신의 코드를 읽을 때, `visited[x][y]`가 방문 상태를 추적한다는 것을 즉시 이해할 수 있습니다.
    
3. **재사용성**: 동일한 데이터 구조에서 여러 번의 탐색을 실행해야 할 경우, 원본 데이터를 수정하면 올바르게 수행할 수 없게 됩니다.
    
4. **유연성**: 더 복잡한 문제에서는 "방문함" 또는 "방문하지 않음" 외에도 거리, 경로, 이전 노드와 같은 추가 정보를 추적해야 할 수 있습니다.
    
5. **디버깅**: 별도의 배열을 사용하면 원본 데이터와 알고리즘 상태를 독립적으로 검사할 수 있어 디버깅이 더 쉬워집니다.
    
6. **교육적 가치**: 학습 목적으로, 별도의 배열을 사용하면 그래프 탐색 알고리즘에 대한 중요한 개념을 강화하는 데 도움이 됩니다.
    

당신의 특정 양배추 문제의 경우, 맵을 직접 수정하는 것이 다음과 같은 이유로 잘 작동합니다:

- 테스트 케이스당 하나의 탐색만 필요합니다
- 맵은 테스트 케이스 사이에 재설정됩니다
- 방문 상태는 이진적입니다(방문함/방문하지 않음)

그러나 별도의 배열을 사용하는 방식이 일반적으로 더 견고하다고 여겨지며, 알고리즘 과정에서 가르치는 표준 관행입니다. 이러한 관례를 따르면 그래프 알고리즘에 익숙한 다른 사람들이 당신의 코드를 더 즉각적으로 인식할 수 있게 됩니다.



### 알고리즘의 Use Case (by Claude)

이 알고리즘은 2D 그리드 에서 연결된 요소들의 클러스터를 식별하고 개수를 세는 것을 목적으로 하며, 다양한 실용적인 응용 사례가 있습니다:

### 환경 응용

- **오염 모니터링**: 수역이나 육지에서 분리된, 오염된 지역들을 식별
- **폐기물 관리**: 위성 이미지를 분석하여 불법 쓰레기 투기 지역 탐지
- **산불 분석**: 산림에서 분리된 화재 지역들을 식별

### 도시 계획 및 인프라

- **도시 개발**: 비어있는 부동산이나 버려진 건물들의 클러스터 식별
- **네트워크 계획**: 유틸리티(수도, 전기, 인터넷)가 부족한 분리된 지역 찾기
- **공공 서비스 최적화**: 쓰레기 수거를 위해 필요한 별도 경로의 수 결정

### 컴퓨터 비전 및 이미지 처리

- **객체 감지**: 이미지에서 구별되는 객체들 식별
- **의료 영상**: 스캔에서 분리된 종양 지역이나 이상 부위 찾기
- **문서 분석**: 개별적인 텍스트 블록이나 그림 식별

### 게임

- **절차적 맵 생성**: 게임 맵이 올바른 수의 분리된 영역을 가지는지 확인
- **경로 찾기**: 장애물로 분리된 이동 가능한 영역 식별
- **게임 로직**: 게임 객체가 유효한 클러스터를 형성하는지 결정(매칭 타일 게임 등)

### 생물학 및 과학 응용

- **세포 군집 분석**: 페트리 접시에서 분리된 세균 군집 계수
- **서식지 분열**: 동물 서식지가 어떻게 분리된 지역으로 나뉘는지 분석
- **질병 확산 모델링**: 격리된 감염 클러스터 식별

### 네트워크 분석

- **소셜 네트워크 분석**: 네트워크에서 분리된 커뮤니티 찾기
- **통신 시스템**: 네트워크 분할이나 고립된 노드 식별
- **회로 설계**: 회로 기판에서 분리된 구성 요소 찾기

이 BFS 기반 알고리즘의 핵심 강점은 2D 그리드에서 연결된 구성 요소를 효율적으로 식별할 수 있다는 것이며, 이는 공간적 클러스터링 분석이 필요한 모든 분야에 널리 적용 가능합니다. 이 알고리즘은 특정 응용 분야에 따라 클러스터의 개수뿐만 아니라 크기, 모양 또는 다른 속성을 측정하도록 쉽게 수정할 수 있습니다.


### 게임프로그래밍에서의 사용 사례 
Question - 그리드안에서 연속된 클러스터를 검증하는 로직이 게임 프로그래밍에서 어떻게 쓰이는지 예제 코드와 예시, 그리고 참조문헌을 제시해서 설명해줄수 있어?

###### Arisu ChatGPT said:

선생님, 2D 그리드에서 연속된 클러스터(connected cluster)를 검증하는 로직은 퍼즐 게임, 전략 시뮬레이션, 타일 매칭 게임 등에서 자주 사용되는 핵심 기능이에요. 예를 들어 "3개 이상 같은 색 블록이 인접하면 제거된다"는 룰의 매치-3 퍼즐 게임이나, 맵상에서 유닛의 연결 여부를 판단하는 전략 게임이 그렇죠.

### 🎮 예시 게임 시나리오

- **게임**: 퍼즐 게임 "슬라임 팡팡"
    
- **목표**: 같은 종류의 슬라임이 3개 이상 인접하면 클리어
    
- **로직 목적**: 슬라임들이 상하좌우로 연결되어 있는지 확인해 클리어 여부 판단
    

---

### 🧠 핵심 개념

이 문제는 **Flood Fill** 또는 **DFS/BFS** 알고리즘으로 해결할 수 있어요.

### 📚 참고 문헌 및 자료

- Red Blob Games: "Flood Fill Algorithm"
    
- StackOverflow: ["Finding connected components in a 2D matrix"](https://stackoverflow.com/questions/48451069)
    
- 게임 프로그래밍 패턴 (Robert Nystrom 저)

**예시코드는 UsecaseCode 참고**