
### 문제 개요
> 상자 안의 토마토들이 익는 과정을 BFS로 시뮬레이션하여,
> 모두 익는 데 걸리는 최소 일수를 구하는 문제.
> 익은 토마토(1)가 주변의 익지 않은 토마토(0)를 하루마다 익게만든다.

#### 입력 형태
- 전제 조건 : 모든 입력이 정상적이라고 생각함.
```python
def 입력_받기():
	열_칸_수, 행_칸_수 = map(int, input().split())
	return 열_칸_수, 행_칸_수

def 상자_만들기(행_칸_수):
	상자 = []
	for _ in range(행_칸_수):
		행 = list(map(int, input().split()))
		상자.append(행)
	return 상자
```

#### BFS 로직 요약
1. 익은 <mark style="background: #FFF3A3A6;">토마토의 좌표</mark>를 큐에 모두 넣는다.
2. 큐에서 하나씩 꺼내어 상, 하, 좌, 우로 익히기.
3. 익은 칸은 이전 칸 값 + 1 로 기록 (며칠째인지 의미).
4. BFS 종료 후  0이 남아 있으면 01, 아니면  max값 -1 출력.

#### 방향 벡터
```python
이동_행 = [-1, 1, 0, 0]   # 위, 아래
이동_열 = [0, 0, -1, 1]   # 왼쪽, 오른쪽
```
```
			[ 상 ]   (x-1, y)
[ 좌 ]   (x, y-1)  [ (x, y) ]  (x, y+1)   [ 우 ]
			[ 하 ]   (x+1, y)
```
```python
def 토마토_익히기(상자, 큐, 이동_행, 이동_열, 열_칸_수, 행_칸_수):
	while 큐:
	현재_행, 현재_열 = 큐.popleft()
		for 방향 in range(4):
			다음_행 = 현재_행 + 이동_행[방향]
			다음_열 = 현재_열 + 이동_열[방향]
				if 0 <= 다음_행 < 행_칸_수 and 0 <= 다음_열 < 열_칸_수:
					if 상자[다음_행][다음_열] == 0:
					상자[다음_행][다음_열] = 상자[현재_행][현재_열] + 1
					큐.append((다음_행, 다음_열))
```
