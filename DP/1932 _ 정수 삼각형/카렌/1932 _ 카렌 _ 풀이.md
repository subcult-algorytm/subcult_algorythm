[1932번: 정수 삼각형](https://www.acmicpc.net/problem/1932)

# 문제

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

위 그림은 크기가 5인 정수 삼각형의 한 모습이다.

맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.

삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.

# 입력

첫째 줄에 삼각형의 크기 n(1 ≤ n ≤ 500)이 주어지고, 둘째 줄부터 n+1번째 줄까지 정수 삼각형이 주어진다.

# 출력

첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.

## 예제 입력 1

```cpp
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

## 예제 출력 1

```cpp
30
```

---

## 코드

```cpp

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	
	int n;
	cin >> n;
	
	vector<vector<int>> triangle(n, vector<int>(n, 0));
	vector<vector<int>> dp(n, vector<int>(n, 0));
	
	//dp[i][j] : 꼭대기에서 i 번째줄, j 번째 칸 까지 내려 왔을때 얻을 수 있는 점수의 최대 값 
	
	// 1. 삼각형 입력 받기
	for(int i = 0; i < n; i++){
		for(int j = 0; j <= i; j++){
			cin >> triangle[i][j];
		}
	}
	
	// 2. 초기값 설정 (피라미드 꼭대기)
	dp[0][0] = triangle[0][0];
	
	// 3. 점화식을 이용해 DP 채우기
	for(int i = 1; i < n; i++){
		for(int j = 0; j <= i; j++){
			// 케이스 1 : 맨 왼쪽 끝 인 경우 (오른쪽 위에서만 내려 올 수 있다)
			if(j == 0){
				dp[i][j] = dp[i-1][j] + triangle[i][j];
			} 
			// 케이스 2 : 맨 오른쪽 끝인 경우 (왼쪽 위에서만 내려 올 수 있다)
			else if(j == i){
				dp[i][j] = dp[i-1][j-1] + triangle[i][j]; 
			} 
			// 케이스 3 : 중간에 있는 경우 (양쪽 위 모두에서 내려 올 수 있다)
			else { 
				dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]; 
			}
		}
	} 
	

	// 4. 정답 찾기 (맨 마지막 줄에서 최댓값 찾기)
	int max_score = 0;

	for(int j = 0; j < n; j++){
		max_score = max(max_score, dp[n-1][j]);
	}

	cout << max_score << "\\n";

	return 0; 
} 
```

## 직각 삼각형으로 바라보기

```cpp
(원래 피라미드)      (배열에 저장된 형태)
      7              [0][0]: 7
    3   8      =>    [1][0]: 3,  [1][1]: 8
  8   1   0          [2][0]: 8,  [2][1]: 1,  [2][2]: 0
```

문제에 나와 있는 것은 직각삼각형으로 안보이지만 직각 삼각형도 삼각형이므로 문제를 풀때 직각삼각형으로 가정하고 문제를 푸는 것이 코드를 짜기 편하다.

## 점화식 자세히 보기

이 문제의 핵심은 세가지 경우의 수로 나누는 것이다.

케이스 1 :맨 왼쪽 끝 인 경우 (오른쪽 위에서만 내려 올 수 있다)

```cpp
if(j == 0)
```

열 번호인 j가 0이라는 것은 가장 왼쪽에 있는 원소라는 뜻이다.

```cpp
dp[i][j] = dp[i-1][j] + triangle[i][j];
```

현재 i층의 첫번째 칸(j=0)에 도달 하는 최대 점수는, 바로 윗층(i-1)의 첫번째 칸 (j=0) 까지의 최대 점수(dp[i-1][j])에 현재 내 점수(triangle[i][j])를 더한 것이다.

케이스 2 : 맨 오른쪽 끝인 경우 (왼쪽 위에서만 내려 올 수 있다)

```cpp
else if(j == i)
```

이번 문제에 쓰인 배열은 행이 내려 갈 수록 칸 수가 하나 늘어나기 때문에 현재 층수인 i와 열 번호인 j가 같다는 것은 그 층의 맨 마지막 칸이다.

```cpp
dp[i][j] = dp[i-1][j-1] + triangle[i][j];
```

현재 i층의 마지막칸 (i=j)에 도달 하는 최대 점수는 바로 윗층(i-1)의 마지막칸 (j-1) 까지의 최대 점수에 현재 내 점수 (triangle[i][j])를 더한 값이다.

케이스 3: 중간에 있는 경우 (양쪽 위 모두에서 내려 올 수 있다)

굳이 조건을 정리하자면 j가 0도 아니고 i도 아닐때이다.

(즉, 양끝이 아닐 때)

```cpp
dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j];
```

max 함수는 인자끼리 비교후 가장 큰 값을 반환한다.

즉 왼쪽 위 대각선, 오른쪽 위 대각선 중 누적 점수가 더 큰 쪽을 더한뒤 내 점수 (triangle[i][j])를 더한다.

## 그리디로 안되는 이유

```cpp
				7
     3   8
  99   1   0
```

그리디 알고리즘의 치명적인 단점은 미래를 보지 못한다는 것이다.

7에서 시작을 한다고 하면 그리디 알고리즘의 경우 8로 가게 되고 그 다음은 1로 가게 된다.

가장 큰 선택지인 99는 선택조차 못하게 된다.

반면에 DP는 참을 수 있다.