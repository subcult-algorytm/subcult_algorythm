[1715번: 카드 정렬하기](https://www.acmicpc.net/problem/1715)

# 문제

정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. 이를테면, 20장의 숫자 카드 묶음과 30장의 숫자 카드 묶음을 합치려면 50번의 비교가 필요하다.

매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다. 이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다. 예를 들어 10장, 20장, 40장의 묶음이 있다면 10장과 20장을 합친 뒤, 합친 30장 묶음과 40장을 합친다면 (10 + 20) + (30 + 40) = 100번의 비교가 필요하다. 그러나 10장과 40장을 합친 뒤, 합친 50장 묶음과 20장을 합친다면 (10 + 40) + (50 + 20) = 120 번의 비교가 필요하므로 덜 효율적인 방법이다.

N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.

# 입력

첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000) 이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다. 숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.

# 출력

첫째 줄에 최소 비교 횟수를 출력한다.

## 예제 입력 1

```cpp
3
10
20
40
```

## 예제 출력 1

```cpp
100
```

# 정답코드

```cpp
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	
	int N;
	cin >> N;
	
	priority_queue<int,vector<int>,greater<int>> pq;
	
	// 1. 최소힙 만들기
	
	for(int i = 0; i < N; i++)
	{
		int x;
		cin >> x;
		pq.push(x);	
	} 
	
	int total_cost = 0;
	
	// 2. 묶음이 하나가 될 때 까지 반복 해 준다.
	
	while(pq.size() > 1)
	{
		// 가장 작은 두 묶음 꺼낸다.
		int a = pq.top(); pq.pop();
		int b = pq.top(); pq.pop();
		
		// 비용 발생 및 누적
		int sum = a+b;
		total_cost += sum;	
		
		// 합친 묶음을 다시 힙에 넣어서 다음 비교에 포함 시켜야 한다. 
		
		pq.push(sum);	
	}
	
	cout << total_cost << "\\n";

	return 0; 
}
```

## 문제 속 그리디 활용

```jsx
	//가장 작은 두 묶음 꺼낸다.
	int a = pq.top(); pq.pop();
	int b = pq.top(); pq.pop();
		
	// 비용 발생 및 누적
	int sum = a+b;
	total_cost += sum;	
```

## 문제 속 최소 힙 활용

1. 최소 힙을 선언 해 준다.

```cpp
priority_queue<int,vector<int>,greater<int>> pq;
```

1. 사용자에게 입력 받은 N만큼 데이터를 받는다.

```cpp
	for(int i = 0; i < N; i++)
	{
		int x;
		cin >> x;
		pq.push(x);	
	} 
	
```

1. 최소 힙으로 정렬 된 두 묶음을 꺼내서 합쳐준다.

```cpp
	while(pq.size() > 1)
	{
		// 가장 작은 두 묶음 꺼낸다.
		int a = pq.top(); pq.pop();
		int b = pq.top(); pq.pop();
		
		// 비용 발생 및 누적
		int sum = a+b;
		total_cost += sum;	
		
		// 합친 묶음을 다시 힙에 넣어서 다음 비교에 포함 시켜야 한다. 
		
		pq.push(sum);	
	}
```

---

## 왜 작은 수 부터 더해야 하는가?

카드 묶음이 10,20,40 세 개가 있다고 가정 한다.

case A : 작은 것 부터 합칠 때 (10+20 먼저)

1. 10 + 20 = 30 (비용 발생 : 30)
2. (만들어진 30) + 40 = 70 (비용 발생 : 70)
3. 총 비용 : 30 + 70 = 100

= > 10과 20은 두 번 씩 더해졌고, 가장 큰 40은 한번만 더해졌다.

(30 자체가 10과 20이 존재하는 것이다.)

case B : 큰 것 부터 합칠 때 (20+40 먼저)

1. 20 + 40 = 60 (비용 발생 60)
2. (만들어진 60) + 10 = 70 (비용 발생 : 70)
3. 총 비용 : 60 + 70 = 130

⇒ 큰 수인 20과 40이 두 번씩 더해져서 총 비용이 case A 보다 커졌다.

(60자체가 20과 40이 존재하는것이다.)

## 왜 합친 묶음을 다시 힙에 넣어야 하는가?

두 묶음을 합치면 , 그 두 묶음은 사라지고 새로운 하나의 묶음이 생긴다.

이 새로운 묶음은 다른 묶음들보다 작을 수도 있고 , 클 수 있다.

공정한 비교를 위해 새로운 묶음을 다시 우선순위 큐에 넣을 필요가 있고,

전체 중에서 다시 가장 작은 두개를 뽑아야 한다.

카드 묶음이 [10,20,25,60] 이 있다고 가정 한다.

1. 가장 작은 10,20을 꺼내 합친다 (sum = 30)
2. 현재 남은 큐는 [25,60] 이 된다.
3. 만약 여기서 30을 큐에 넣지 않고 따로 빼두면 25+60 이므로 비용은 85가 된다.

↔ 하지만 아까 만든 30과 큐에 있는 25를 합치는 쪽이 더 이득 이다. (25+30 = 55)

1. 30을 큐에 다시 넣어주면 [25,60]이 남는것이 아닌 [25,30,60]으로 재정렬 된다.
2. 여기서 top() 을 하면 25와 30이 나와서 최적의 합 (55)를 만들 수 있다.

---

## 최소 힙의 특징과 시간 복잡도

특징: 새로운 값 sum을 넣었을 때 (push) 자동으로 정렬된 상태를 유지하여 다음 번 최솟값을 O(1)만에 접근(top) 한다.

시간복잡도: O(logN)

삽입/삭제 :O(NlogN)

전체 과정 : N개의 데이터를 힙에 넣고 빼므로 O(NlogN)

↔ 만약 배열을 매번 정렬 했을 경우 O(N^2logN) 혹은 O(N^2)가 된다.