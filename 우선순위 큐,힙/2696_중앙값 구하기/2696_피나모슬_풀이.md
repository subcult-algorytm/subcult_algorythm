[2696번: 중앙값 구하기](https://www.acmicpc.net/problem/2696)

## 문제

어떤 수열을 읽고, 홀수번째 수를 읽을 때 마다, 지금까지 입력받은 값의 중앙값을 출력하는 프로그램을 작성하시오.

예를 들어, 수열이 1, 5, 4, 3, 2 이면, 홀수번째 수는 1번째 수, 3번째 수, 5번째 수이고, 1번째 수를 읽었을 때 중앙값은 1, 3번째 수를 읽었을 때는 4, 5번째 수를 읽었을 때는 3이다.


## 입력

첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 각 테스트 케이스의 첫째 줄에는 수열의 크기 M(1 ≤ M ≤ 9999, M은 홀수)이 주어지고, 그 다음 줄부터 이 수열의 원소가 차례대로 주어진다. 원소는 한 줄에 10개씩 나누어져있고, 32비트 부호있는 정수이다.

## 출력

각 테스트 케이스에 대해 첫째 줄에 출력하는 중앙값의 개수를 출력하고, 둘째 줄에는 홀수 번째 수를 읽을 때 마다 구한 중앙값을 차례대로 공백으로 구분하여 출력한다. 이때, 한 줄에 10개씩 출력해야 한다.

## 풀이 코드

```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <string>
#include <unordered_map>
#include <stack>
#include <cmath>
using namespace std;
int N, M;
int T;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> T;

    while (T--) {
        priority_queue<int> maxheap;
        priority_queue<int, vector<int>, greater<int>> minheap;
        vector<int> ans;
        cin >> N;

        for (int y = 0; y < N; ++y) {
            int ct;
            cin >> ct;
            if (y == 0) {
                maxheap.push(ct);
            }
            else if (y == 1) {
                if (ct > maxheap.top())
                    minheap.push(ct);
                else {
                    minheap.push(maxheap.top());
                    maxheap.pop();
                    maxheap.push(ct);
                }
            }
            else {
                maxheap.push(ct);

                if (maxheap.top() > minheap.top()) {
                    maxheap.pop();
                    minheap.push(ct);

                    if (minheap.size() > maxheap.size()) {
                        maxheap.push(minheap.top());
                        minheap.pop();
                    }
                }

                if (maxheap.size() - minheap.size() > 1) {
                    minheap.push(maxheap.top());
                    maxheap.pop();
                }
                
            }
            if (y % 2 == 0) {
                ans.push_back(maxheap.top());
            }
        }

        cout << ans.size() << "\n";
        for (int y = 0; y < ans.size(); ++y) {
            if (y > 0 && y % 10 == 0) cout << "\n";
            cout << ans[y] << " ";
        }
        cout << "\n";
    }


    return 0;
}
```

---

## 중요한 부분(핵심)

중요한 부분은 '가운데'값을 구하는 것. 따라서 수는 정렬되어 있어야 하며, 그 중에서도 '가운데'를 구해야한다. 

따라서 우리는 삽입때마다 정렬되며, 

1000 * 10000이기 때문에, 1000만. 따라서, 적어도 NlogN의 시간 복잡도를 가져야한다. 

그래서 만든 방법은 minheap(큰 쪽 절반), maxheap(작거나 같은 쪽 절반)이렇게 나누는 방법이다.


## 세부 로직. 

새로운 값이 들어오면. maxheap은 현재까지의 값들 중 “작은 절반”을 담고, 그 중 최댓값이 top에 오도록 합니다.

minheap은 큰 절반을 담고 있다. 그 중 최솟값이 top에 오게하면, 

[1 2 3 4 ] [ 5 6 7 8 9]((실제로는 9 8 7 6 5)) 이런식의 배치가 되는데,. 5를 꺼내서 쓰면 된다.

이때 항상 maxheap.size()가 minheap.size()나, maxheap.size() == minheap.size() + 1를 유지하면 중앙값은 곧 maxheap.top이 된다. 

한 번 데여보면 어렵지 않게 풀 수 있는 유형이라고 생각한다. 